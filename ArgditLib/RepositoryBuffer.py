from .Constants import SEQ_VERSION_MARKUP
from .ProcLog import ProcLog
from Bio import SeqIO

'''
Repository buffer class to manipulate the sequence records for the merged database

---Attributes---
input_seq_record_src_tags: A mapping between input sequences (strings) with a 3-tuple containing
                           sequence record, source database, and original sequence header
same_header_seq_str_grps: A mapping between a sequence header with a set of distinct sequences (strings)
                          with this header: addressing multiple sequence versions for the same sequence
                          header
is_auto_annotate: Indicates whether the sequence annotation is auto-generated by ARGDIT
'''
class RepositoryBuffer:
    def __init__(self):
        self._input_seq_record_src_tags = dict()
        self._same_header_seq_str_grps = dict()
        self._is_auto_annotate = False

    '''
    Function name: add
    Inputs       : ARG sequence record to export, source ARG database file path, and original sequence
                   header
    Outputs      : Nil
    Description  : Adds the ARG sequence record to the repository, together with keeping track of its
                   source database as well as its original sequence header (as the annotation in the
                   sequence record may be auto-generated)
    '''
    def add(self, seq_record, source_db_file_path, org_seq_header):
        forward_seq_str = str(seq_record.seq)
        rev_comp_seq_str = str(seq_record.seq.reverse_complement())

        '''
        SEQ_VERSION_MARKUP is embedded in every auto-generated annotation so that unique numerical IDs
        (sequence version numbers) will be assigned to non-redundant sequences having identical
        annotation. Hence this markup is an indicator of auto-generated annotation
        '''
        if not self._is_auto_annotate:
            if seq_record.id.find(SEQ_VERSION_MARKUP) > -1:
                self._is_auto_annotate = True

        '''Sequence record with identical sequence and header as those previously added is ignored'''
        if seq_record.id in self._same_header_seq_str_grps:
            same_header_seq_strs = self._same_header_seq_str_grps[seq_record.id]
            if forward_seq_str not in same_header_seq_strs and rev_comp_seq_str not in same_header_seq_strs:
                same_header_seq_strs.add(forward_seq_str)
        else:
            self._same_header_seq_str_grps[seq_record.id] = {forward_seq_str}

        if forward_seq_str in self._input_seq_record_src_tags:
            self._input_seq_record_src_tags[forward_seq_str].append((seq_record, source_db_file_path, org_seq_header))
            return

        if rev_comp_seq_str in self._input_seq_record_src_tags:
            self._input_seq_record_src_tags[rev_comp_seq_str].append((seq_record, source_db_file_path, org_seq_header))
        else:
            self._input_seq_record_src_tags[forward_seq_str] = [(seq_record, source_db_file_path, org_seq_header)]

    '''
    Function name: _select_most_version_seq
    Inputs       : A list of 3-tuples (sequence record, source ARG database file path, and original
                   sequence header) having identical (i.e. redundant) nucleotide/protein sequence
    Outputs      : List index of the 3-tuple of which its output annotation (i.e. sequence header) has
                   the largest number of different sequence versions, and a boolean indicating whether
                   multiple sequence versions exist for this annotation
    Description  : In case when only non-redundant sequences are allowed in the merged output database,
                   select the one whose output anotation (sequence header) has the most sequence
                   versions among redundant sequences
    '''
    def _select_most_version_seq(self, redundant_seq_record_src_tags):
        max_version_count = 0
        max_version_seq_hdr_index = None

        for i in range(0, len(redundant_seq_record_src_tags)):
            seq_record = redundant_seq_record_src_tags[i][0]
            if seq_record.id in self._same_header_seq_str_grps:
                version_count = len(self._same_header_seq_str_grps[seq_record.id])
            else:
                version_count = 1

            if version_count > max_version_count:
                max_version_seq_hdr_index = i
                max_version_count = version_count

        return max_version_seq_hdr_index, (max_version_count > 1)

    '''
    Function name: _select_least_version_seq
    Inputs       : A list of 3-tuples (sequence record, source ARG database file path, and original
                   sequence header) having identical (i.e. redundant) nucleotide/protein sequence
    Outputs      : List index of the 3-tuple of which its output annotation (i.e. sequence header) has
                   the lowest number of different sequence versions, and a boolean indicating whether
                   multiple sequence versions exist for this annotation
    Description  : In case when only non-redundant sequences are allowed in the merged output database,
                   select the one whose output anotation (sequence header) has the least sequence
                   versions among redundant sequences
    '''
    def _select_least_version_seq(self, redundant_seq_record_src_tags):
        min_version_count = None
        min_version_seq_hdr_index = None

        for i in range(0, len(redundant_seq_record_src_tags)):
            seq_record = redundant_seq_record_src_tags[i][0]
            if seq_record.id in self._same_header_seq_str_grps[seq_record.id]:
                version_count = len(self._same_header_seq_str_grps[seq_record.id])
            else:
                return i, False

            if min_version_count is None or version_count < min_version_count:
                min_version_seq_hdr_index = i
                min_version_count = version_count

        return min_version_seq_hdr_index, (min_version_count > 1)

    '''
    Function name: _pop_seq_record_src_tag
    Inputs       : A list of 3-tuples (sequence record, source ARG database file path, and original
                   sequence header) and the list index of the 3-tuple to be popped
    Outputs      : The popped 3-tuple and remaining 3-tuples
    Description  : Pops the 3-tuple from the input list according to the given list index
    '''
    @staticmethod
    def _pop_seq_record_src_tag(seq_record_src_tags, pop_idx):
        residue_seq_record_src_tags = list(seq_record_src_tags)       
        popped_seq_record_src_tag = residue_seq_record_src_tags.pop(pop_idx)

        return popped_seq_record_src_tag, residue_seq_record_src_tags

    '''
    Function name: _assign_seq_version_to_seq_header
    Inputs       : Sequence record, assigned version counts for auto-generated annotation, and boolean
                   indicating whether the sequence record is one of the multiple versions
    Outputs      : Annotation (sequence header) with sequence version number assigned to replace the
                   SEQ_VERSION_MARKUP field in the auto-generated annotation
    Description  : If the input sequence record belongs to one of the multiple sequence versions,
                   assigns a new sequence version number to the SEQ_VERSION_MARKUP field in the auto-
                   generation annotation. Replaces the field with an empty string when no multiple
                   sequence version exists
    '''
    @staticmethod
    def _assign_seq_version_to_seq_header(seq_record, seq_version_counts, is_multiple_version):
        if not is_multiple_version:
            version_label = ''
        else:
            if seq_record.id in seq_version_counts:
                seq_version_counts[seq_record.id] += 1
            else:
                seq_version_counts[seq_record.id] = 1

            version_label = 'version{}'.format(seq_version_counts[seq_record.id])

        return seq_record.id.replace(SEQ_VERSION_MARKUP, version_label)

    '''
    Function name: _export_non_redundant_seqs
    Inputs       : Nil
    Outputs      : Sequence records to export
    Description  : Exports non-redundant sequence records
    '''
    def _export_non_redundant_seqs(self):
        output_seq_records = list()

        '''
        If auto-generation annotation is enabled, need to keep track of the sequence verison number.
        Otherwise, the exported sequence headers need to be recorded to avoid duplicated sequence
        headers.
        '''
        if self._is_auto_annotate:
            seq_version_counts = dict()
        else:
            exported_seq_headers = set()

        for redundant_seq_record_src_tags in self._input_seq_record_src_tags.values():
            '''
            Since only one sequence record in redundant_sequence_record_src_tags is exported, need to
            sort the 3-tuple list to ensure the same sequence record (and hence header) is always
            selected for export in every run
            '''
            ordered_redundant_seq_rec_src_tags = \
                sorted(redundant_seq_record_src_tags, key = lambda seq_record_src_tag:seq_record_src_tag[0].id)
            '''
            Highlight multiple sequence versions for auto-generated annotation and avoid identical
            sequence headers (and hence multiple sequence versions) as much as possible when annotation
            is not generated
            '''
            if self._is_auto_annotate:
                selected_seq_idx, is_multiple_version = \
                    self._select_most_version_seq(ordered_redundant_seq_rec_src_tags)
            else:
                selected_seq_idx, _ = \
                    self._select_least_version_seq(ordered_redundant_seq_rec_src_tags)

            selected_seq_record_src_tag, unselected_seq_record_src_tags = \
                self._pop_seq_record_src_tag(ordered_redundant_seq_rec_src_tags, selected_seq_idx)
            selected_seq_record = selected_seq_record_src_tag[0]

            if self._is_auto_annotate:
                '''Fill the SEQ_VERSION_MARKUP with actual sequence version'''
                selected_seq_record.id = self._assign_seq_version_to_seq_header(selected_seq_record, seq_version_counts,
                                                                                is_multiple_version)
            else:
                if selected_seq_record.id in exported_seq_headers:
                    ProcLog.log_cross_db_duplicated_header(selected_seq_record_src_tag, self._is_auto_annotate)
                    continue
                else:
                    exported_seq_headers.add(selected_seq_record.id)

            output_seq_records.append(selected_seq_record)

            for seq_record_src_tag in unselected_seq_record_src_tags:
                ProcLog.log_cross_db_redundant_seq(seq_record_src_tag)

        return output_seq_records

    '''
    Function name: _export_redundant_seqs
    Inputs       : Nil
    Outputs      : Sequence records to export
    Description  : Exports redundant sequence records
    '''
    def _export_redundant_seqs(self):
        output_seq_records = list()
        
        '''
        If auto-generation annotation is enabled, need to keep track of the sequence verison number.
        Otherwise, the exported sequence headers need to be recorded to avoid duplicated sequence
        headers.
        '''
        if self._is_auto_annotate:
            seq_version_counts = dict()
        else:
            exported_seq_headers = set()

        for redundant_seq_record_src_tags in self._input_seq_record_src_tags.values():
            '''
            Keep track of duplicated sequence headers for those with redundant sequence, as for
            auto-generated annotation, the sequence headers will be unique after assigning sequence
            version number
            '''
            same_seq_exported_hdrs = set()

            '''Sort the 3-tuple list to ensure same set of sequence records exported in every run'''
            for seq_record_src_tag in sorted(redundant_seq_record_src_tags,
                                             key = lambda seq_record_src_tag:seq_record_src_tag[0].id):
                seq_record = seq_record_src_tag[0]

                if seq_record.id in same_seq_exported_hdrs:
                    ProcLog.log_cross_db_duplicated_header(seq_record_src_tag, self._is_auto_annotate)
                    continue
                else:
                    same_seq_exported_hdrs.add(seq_record.id)
                    
                if self._is_auto_annotate:
                    '''Fill the SEQ_VERSION_MARKUP with actual sequence version'''
                    is_multiple_version = seq_record.id in self._same_header_seq_str_grps and \
                                          len(self._same_header_seq_str_grps[seq_record.id]) > 1

                    seq_record.id = self._assign_seq_version_to_seq_header(seq_record, seq_version_counts,
                                                                           is_multiple_version)
                else:
                    if seq_record.id in exported_seq_headers:
                        ProcLog.log_cross_db_duplicated_header(seq_record_src_tag, self._is_auto_annotate)
                        continue
                    else:
                        exported_seq_headers.add(seq_record.id)

                output_seq_records.append(seq_record)

        return output_seq_records

    '''
    Function name: export
    Inputs       : Output ARG database file path, boolean controlling the export of redundant sequences
    Outputs      : Total number of sequences exported
    Description  : Exports all qualified ARG sequences to the output database
    '''
    def export(self, output_file_path, is_no_redundant_seq = True):

        if is_no_redundant_seq:
            output_seq_records = self._export_non_redundant_seqs()
        else:
            output_seq_records = self._export_redundant_seqs()

        with open(output_file_path, 'w') as f:
            SeqIO.write(output_seq_records, f, 'fasta')

        return len(output_seq_records)
